#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Shifts a white matter surface inward along a Laplace field

Parameters
----------
GIFTI  :    str
            White matter surface in GIFTI format (surf.gii)
NIFTI  :    str
            laplacian image generated by laplace_solver.py
OUTPUT :    str
            path and name to the output surfaces
DEPTHS :    list [int | float] (OPTIONAL)
            DEFAULT=[1,2,3] List of depths to sample (in mm)

Returns
-------
NIFTI
    a list of strings representing the header columns

Usage
-----
surface_generator.py hemi-L_label-white.surf.gii laplace-wm.nii.gz hemi-L_label-sWF_depth-

Created on October 2023

@author: Jordan DeKraker
code from https://github.com/khanlab/hippunfold/blob/master/hippunfold/workflow/scripts/create_warps.py

"""
import copy
import nibabel as nib
import numpy as np
from scipy.interpolate import RegularGridInterpolator
import sys
from scipy.spatial.distance import cdist
import time


def build_adjacency_map(F):
    """Build efficient adjacency mapping for vertices."""
    n_vertices = np.max(F) + 1
    adjacency = [[] for _ in range(n_vertices)]
    
    for face in F:
        for i in range(3):
            for j in range(3):
                if i != j:
                    adjacency[face[i]].append(face[j])
    
    # Convert to sets to remove duplicates, then back to arrays
    adjacency = [np.array(list(set(adj))) for adj in adjacency]
    return adjacency


def avg_neighbours_vectorized(adjacency, cdat, zero_indices):
    """Vectorized neighbor averaging."""
    result = np.zeros(len(zero_indices))
    for i, vertex_idx in enumerate(zero_indices):
        neighbors = adjacency[vertex_idx]
        if len(neighbors) > 0:
            result[i] = np.nanmean(cdat[neighbors])
        else:
            result[i] = 0.0
    return result


def arg2float_list(arg):
    return list(map(float, arg.split(",")))


def shift_surface(in_surf, in_laplace, out_surf_prefix, depth_mm=[1, 2]):
    start_time = time.time()
    print("starting surface shift")

    # Load data
    surf = nib.load(in_surf)
    V_original = surf.get_arrays_from_intent("NIFTI_INTENT_POINTSET")[0].data.astype(np.float32)
    F = surf.get_arrays_from_intent("NIFTI_INTENT_TRIANGLE")[0].data
    laplace = nib.load(in_laplace)
    lp = laplace.get_fdata().astype(np.float32)
    
    print(f"loaded data and parameters in {time.time() - start_time:.2f}s")

    # Get image resolution
    affine = laplace.affine
    xres, yres, zres = affine[0, 0], affine[1, 1], affine[2, 2]

    # Convert depth values to strings with a specific format
    depth_str = [f"{d:.1f}" for d in depth_mm]  # Use one decimal place

    step_size = 0.1  # vox
    
    # Pre-compute gradient once
    gradient_start = time.time()
    dx, dy, dz = np.gradient(lp)
    
    # Scale the gradients by the image resolutions to handle anisotropy
    dx = dx / xres
    dy = dy / yres  
    dz = dz / zres
    print(f"computed gradients in {time.time() - gradient_start:.2f}s")

    # Build adjacency map once
    adj_start = time.time()
    adjacency = build_adjacency_map(F)
    print(f"built adjacency map in {time.time() - adj_start:.2f}s")
    
    # Pre-compute affine transformations
    translation = affine[:3, 3]
    scales = np.array([affine[0, 0], affine[1, 1], affine[2, 2]])
    inv_scales = 1.0 / scales

    V = V_original.copy()
    
    for depth_idx, (depth, d_str) in enumerate(zip(depth_mm, depth_str)):
        iter_start = time.time()
        print(f"Generating surface at depth {d_str}mm...")
        
        # Reset to original surface for each depth
        if depth_idx > 0:
            V = V_original.copy()
        
        nsteps = int(depth / step_size)
        
        # Transform to voxel space once
        V_vox = (V - translation) * inv_scales
        
        for step in range(nsteps):
            # Get integer coordinates for gradient lookup
            V_int = np.round(V_vox).astype(np.int32)
            
            # Clip coordinates to valid range
            V_int[:, 0] = np.clip(V_int[:, 0], 0, dx.shape[0] - 1)
            V_int[:, 1] = np.clip(V_int[:, 1], 0, dx.shape[1] - 1)
            V_int[:, 2] = np.clip(V_int[:, 2], 0, dx.shape[2] - 1)
            
            # Get gradient vectors at vertices
            stepx = dx[V_int[:, 0], V_int[:, 1], V_int[:, 2]]
            stepy = dy[V_int[:, 0], V_int[:, 1], V_int[:, 2]]
            stepz = dz[V_int[:, 0], V_int[:, 1], V_int[:, 2]]
            
            # Find vertices with zero gradients
            zero_mask = (stepx == 0) & (stepy == 0) & (stepz == 0)
            zero_indices = np.where(zero_mask)[0]
            
            # Use neighbor averaging for zero gradients
            if len(zero_indices) > 0:
                stepx[zero_indices] = avg_neighbours_vectorized(adjacency, stepx, zero_indices)
                stepy[zero_indices] = avg_neighbours_vectorized(adjacency, stepy, zero_indices)
                stepz[zero_indices] = avg_neighbours_vectorized(adjacency, stepz, zero_indices)
            
            # Vectorized magnitude normalization
            magnitude = np.sqrt(stepx**2 + stepy**2 + stepz**2)
            valid_mask = magnitude > 0
            
            # Normalize step vectors
            scale_factor = step_size / magnitude
            stepx[valid_mask] *= scale_factor[valid_mask]
            stepy[valid_mask] *= scale_factor[valid_mask] 
            stepz[valid_mask] *= scale_factor[valid_mask]
            
            # Update positions in voxel space
            V_vox[:, 0] += stepx
            V_vox[:, 1] += stepy
            V_vox[:, 2] += stepz
        
        # Transform back to world coordinates
        V = V_vox * scales + translation
        
        # Create new surface with updated vertices
        new_surf = nib.gifti.GiftiImage()
        
        # Copy vertex data
        vertex_data = nib.gifti.GiftiDataArray(
            data=V,
            intent='NIFTI_INTENT_POINTSET',
            datatype='NIFTI_TYPE_FLOAT32'
        )
        new_surf.add_gifti_data_array(vertex_data)
        
        # Copy face data from original
        face_data = surf.get_arrays_from_intent("NIFTI_INTENT_TRIANGLE")[0]
        new_surf.add_gifti_data_array(face_data)
        
        # Save surface
        output_file = out_surf_prefix + d_str + "mm.surf.gii"
        nib.save(new_surf, output_file)
        
        print(f"generated surface at depth {d_str}mm in {time.time() - iter_start:.2f}s")
    
    print(f"Total surface generation time: {time.time() - start_time:.2f}s")


# Example usage
if __name__ == "__main__":
    in_surf = sys.argv[1]
    in_laplace = sys.argv[2]
    out_surf_prefix = sys.argv[3]
    if len(sys.argv) > 4:
        depth_mm = arg2float_list(sys.argv[4])
    else:
        depth_mm = [1, 2, 3]  # default depths in mm

    shift_surface(in_surf, in_laplace, out_surf_prefix, depth_mm)
